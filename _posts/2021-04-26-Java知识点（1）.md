---
layout: post
title: Java知识点（1）
date: 2021-04-26
Author: Jack
categories: [JAVA]
tags: [JVM]
comments: true
---

发现自己太久没写Java，基础知识有些忘了，从今天开始每天复习一点Java的基础知识。

**JVM内存模型**

Java运行要用到以下几个区域：

* 运行数据区（Runtime Data Area）
* 执行引擎（Execution Engine）
* 本地接口 （Native Interface）
* 本地库 （Native Libraries）

运行数据区又氛围线程共享区和线程私有区。线程共享区包括了方法区（Method Area）以及堆（Heap）。线程私有区包括了虚拟机栈（VM Stack）本地方法栈（Native Method Stack）以及程序计数器（Program Counter Register）

* JDK 1.8 同JDK 1.7 相比，最大的差别就是用元数据区取代了永久代。元数据区的本质和永久代类似，都是方法区的实现，只不过元数据使用的不再是堆内存，而是本地内存。

*堆区*

堆区是JVM管理的内存中最大的一块，主要用来存放Java对象和数组。这个区域被所有的线程共享。Java堆在物理上可以储存在不连续的内存空间中，但在逻辑上它应该被视为连续的。从GC的角度来划分，可以分为年轻代和老年代。年轻代又包括Eden空间，From Survivor，To Survivor空间，默认情况下，年轻代按照8：1：来分配。

Java堆可以设置成固定大小或者可拓展大小。用`-Xms`和`-Xmx`分别设置最小和最大空间。此外，可以用`-XX:NewSize`来设置新生代最小空间，用`-XX:MaxNewSize`来设置新生代最大空间。用`-Xss`设置每个线程的堆栈大小。没有直接设置老年代的参数，但是可以设置设置堆空间大小以及新生代空间大小来控制。当线程请求分配内存，但堆已经满乐的，且无法再拓展内存时，就会抛出`OutOfMemoryError`异常。

JAVA虚拟机启动时会创建堆。

*方法区*

方法区是堆得一个逻辑部分，用来存放一下信息

* 被JVM加载的Class信息
* 常量
* 静态变量
* 即时编译器编译后的代码

方法区也是线程共享的，和堆一样，整个JVM只有一个方法区。方法区的信息一般都需要长期存在，所以方法区也被称为永久代。

运行时常量池

当Class文件被JVM加载后，.class文件中的常量就存放在方法取得运行时常量池。在运行期间，可以向常量池新的常量。如String类的intern（）方法就可以在运行期间向常量池中添加字符串常量。

*直接内存*

直接内存是除Java虚拟机之外的内存，但是也可以被Java使用。在NIO中引入了一种基于通道和缓冲的IO，他可以通过调用本地方法直接分配JVM之外的内存，然后通过一个储存在堆中的DirectByteBuffer对象直接操作该内存，这样不需要将外部内存的数据复制到堆中再操作，从而提高了数据操作的效率。虽然直接内存的大小不受JVM控制，但是当内存不足时，仍旧会抛出OurOfMemoryError。

直接内存和堆内存的比较：

* 直接内存申请空间小高更高的性能。
* 直接内存读取IO的性能优于堆内存。
* 直接内存作用链 本地IO -> 直接内存 ->本地IO
* 堆内存作用链 本地IO -> 直接内存 -> 堆内存 -> 直接内存 -> 本地IO

*程序计数器*

程序计数器是一块较小的内存空间，代表的当前线程正在执行的那条字节码的地址。如果当前线程正在执行的是一个本地方法，那么此时程序计数器为undefined。字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制。多线程情况下，程序计数器记录的是当前线程执行的位置，从而当线程切换回来时，就知道上次线程执行到哪了。程序计数器是线程私有的，它随着线程的创建而创建，随着线程的结束而销毁。它是唯一不会出现OutOfMemoryError的内存区域。

*JVM栈 Stack*

JVM Stack是描述Java方法运行过程的内存模型。JVM stack会为每一个即将运行的Java方法创建一块叫做栈帧的区域。栈帧里面存放了该方法运行过程中的一些信息，比如：

* 局部变量表
* 操作数栈
* 动态链接
* 方法出口信息

入栈出栈过程：

当方法运行过程中需要创建局部变量时，就将局部变量的值存入栈帧中的局部变量表中。

JVM Stack栈顶的栈帧就是当前执行的活动栈，代表的是当前正在执行的方法。程序计数器也会指向这个地址。只有这个活动的栈帧的本地变量可以被操作数栈使用，当在这个栈帧中调用另一个方法，与之对应的栈帧又会被创建，新创建的栈帧压入栈顶，变为当前的活动站镇。方法结束后，当前的栈帧将会被移除，栈帧的返回值将会变成新的活动栈帧中操作数栈的一个操作数。如果无返回值，那么新的活动栈帧中操作数栈的操作数没有变化。

局部变量表储存着方法的参数和局部变量，这些表项可以是基本数据里诶性和引用数据类型。应用数据类型需要做到以下两点：1）通过这个引用能够找到这个引用对象在堆中数据存放的起始地址入口，也就是指对象在内存中的物理地址。2）通过这个引用能够找到对象的实例类型在方法区中的类型信息。也就是class变量以及方法的具体细节。局部变量表的容量以slot为最小单位。一个32位的虚拟机中的slot可以放4bytes以内的数据列新（boolean， byte, char, short, int, float, reference以及returnAddress八种）对于8bytes的数据类型（long，double）虚拟机会为他们分配两个连续的slot空间。Slot是可以冲用的，当slot中的变量超过了作用于，那么下一次分配slot的时候，将会覆盖原来的数据。Slot对对象的引用会影响GC，因为如果一个变量还在被引用，就不会被回收。系统不会为局部变量赋予初始值（实例变量和类变量都会有初始值）局部变量不像的类成员变量那样存在"准备阶段"。类变量有两次赋初始值的过程，一次在准备阶段，赋予系统初始值；另外一次在初始化阶段，赋予程序员定义的初始值。因此，即使在初始化阶段程序员没有为类变量赋值也没有关系，类变量仍然具有一个确定的初始值。但局部变量就不一样，如果一个局部变量定义了但没有赋初始值是不能使用的。

操作数栈用来执行方法中的具体代码，比如操作数栈里面的每一个元素可以是任意的Java数据类型，4bytes的数据类型占用一个栈容量，8bytes的占用两个栈容量。当一个方法刚刚开始执行的时候，这个方法的操作数栈是空的，在方法执行的过程中，会有各种字节码向操作数栈中写入和提取内容（入栈，出栈）。有时，为了性能优化，避免额外复制，有时操作数栈将与其他栈帧的局部变量表共享区域有重叠。如果当前的线程请求的栈深度大于JVM设置的最大深度，就会抛出StackOverFlowError。如果内存不足，也会抛出OurOfMemoryError。

动态链接：每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用。持有这个引用是为了支持方法调用过程中的动态链接。.class文件中的常量池有大量的符号引用，自己吗中的方法调用指令就是以常量池中指向方法的符号引用作为参数。这些符号引用一部分会在类加载阶段或者第一次使用的时候转化为直接饮用，这种转化被称为静态解析。另一部分将在每一次运行期间转化为直接饮用，这部分被称为动态链接。Java代码在Javac编译的时候不会有连接操作，链接操作发生于JVM加载class文件的时候。这就是说，.class文件中并不保存各个方法字段的内存布局信息，因此如果不通过运行期进行转换的话，方法和字段无法得到真正的运行内存地址。当虚拟机运行的时候，需要从常量池中获得对应的符号引用，然后在类创建或者运行时解析，翻译到具体的内存地址之中。比如object.toString()调用时toString()叫做符号，通过这个符号到常量池中找到对应的方法的符号引用，然后运行时通过这个符号引用找到方法对应的的字节码指令的内存地址。

方法出口信息：当一个方法开始执行后只有两种方法可以退出这个方法。1）执行引擎遇到方法中return代表的字节码指令，这种时候有可能会将返回值传递给上层的方法调用者。这种方法叫正常完成出口。2）如果在执行过程中遇到了异常，并且这个异常没有在方法中得到处理，这种情况会导致方法退出，这种方法叫异常完成出口。一个方法使用异常完成出口的方式退出，是不会给它的上层调用者产生任何返回值的。无论何种退出方式，方法推出后，都需要返回到方法被调用的位置，这样程序才能继续执行，因此方法返回时可能需要在栈帧中保存一些信息，用于帮助恢复它的上层方法的执行状态。一般来说，当方法正常退出时，调用者的程序计数器的值可以作为返回地址，栈帧中应该会记录这个计数器的值。而方法异常退出时，返回的地址要通过异常处理器来确定。方法退出就相当于把当前的栈帧出栈，因此退出时将会恢复调用方法的局部变量表和操作数栈，把返回值压入调用方法的操作数栈，调整程序计数器的值从而使调用方法继续执行。

*本地方法栈*

本地方法栈是为了JVM运行Native方法准备的空间，它和虚拟机栈的功能类似，只不过本地方法栈是用来描述本地方法运行过程的内存模型。